# 操作系统实验报告

##### 201840058 蒋潇鹏

## L0 hello-os

#### 实现库函数

在ICS中我已经实现了全部的库函数，这里我将他们直接移植过来了。

在stdio.c中我发现函数对共享内存进行了操作，并且printf对putch的调用不能保证输出的原子性，因此我在klib中实现了一个简单的自旋锁，并在这两个地方添加

#### 访问IO设备

这部分我直接魔改了L0的框架代码，把splash函数的调用移到了while(1)中，之后遍历每一个像素点，进行打印。

对于键盘输入，也可以将print_key中的操作魔改一下，当读取到Escape时，调用halt(0)

#### 绘制一个图片

首先我找了一张图片：
![](/home/birdium/os-workbench/kernel/mrs.png)

之后用如下命令将其转换为一个rgb阵列：
```shell
convert mrs.png mrs.rgb
xxd -i mrs.rgb mrs.c
```

这样在`mrs.c`文件中就有了我需要的一个大数组，在splash中用如下代码打印：
```C
  for (int x = 0; x < w; x ++) {
    for (int y = 0; y < h; y++) {
      int loc = (y * IMG_HEIGHT / h) * IMG_WIDTH + (x * IMG_WIDTH / w); 
      unsigned int col = (mrs_rgb[3 * loc] << 16) + 
                         (mrs_rgb[3 * loc + 1] << 8) +
                         (mrs_rgb[3 * loc + 2]);
      draw_tile(x, y, 1, 1, col);
    }
  }
```

## L1 pmm

#### 架构设计

我的设计参考了buddy system和slab的做法，以及mimalloc的部分思想

1. 首先对于堆区的划分：我将堆区的每一页映射到了一个数组 `TableEntry table[MAX_HEAP_SIZE]`, 这个数组起始地址为heap.start, 每个TableEntry维护其对应页面的一些信息，比如大小（2的多少幂次），是否可用，被哪个cpu所分配等各种信息。

2. 对于大内存的分配（>=2page），使用buddy system分配。buddy system维护数个链表，分别存放8KiB, 16KiB, ..., 4MiB的内存项。当进行分配的时候，从恰好满足的大小对应链表开始，对链表上锁，找一片可用内存，将其从链表中移除。如果没有可用内存，就去寻找更大的大小对应的链表。在移除时，在`table`数组中记录它的大小，并将其标记为已分配。当进行释放时，找到table中对应Entry中记录的该内存地址对应区间的大小，将其加入对应链表。加入后检查是否存在可以合并的区间，如果有则合并。

3. 对于小内存的分配，使用slab。slab为每个CPU维护两份缓存链表，一份是local链表，包含了自己申请自己释放的内存空间。一份是thread链表，包含了自己申请其他CPU释放的内存空间。（参考了mimalloc）。在分配时，优先选择local链表。如果local链表不满足，则尝试获取thread链表的锁。依然不满足，则使用buddy system申请大小为4页的内存空间，平均分成数分插入到当前链表之中。在内存分配的时候，保证了一个page上的所有内存都只可能被一个CPU所分配，因此可以在`table`数组中记录这一点。对于内存的释放，判断是哪个CPU分配的，如果分配和释放的是相同CPU，将其插入local list中。否则获取分配CPU对应thread链表的锁，插入thread list之中。

#### 精巧实现

1. 对于页信息使用了`table`来存储，这样就可以用一个相对较小的内存占用来很方便地记录页的meta data。

2. 对于slab中的小区间将信息直接存在对应地址空间中，通过保证每个小区间对应的page只会被一个CPU分配，使得meta data能直接存在`table`数组中

3. 完成了TEST框架的构建，实现了不同等级的日志，能够很方便地进行测试。在这次实验中，thread sanitizer 为我排查了很多并发bug，大大增加了调试效率。

#### 印象深刻的bug

1. 遇到了许多并发bug，首先是因为我buddy system的设计，我是直接用table数组来表示区间的，把区间长度存在table数组里，想要获取其对应的链表，需要先获取长度，因此获取长度的时候没法给链表加锁，导致了这一块可能出现数据竞争。最后用了给table数组加锁的方式来解决。如果重新设计，我会选择用一个类似线段树的方法去表示区间，而不是把表示区间的信息混合在table数组中。